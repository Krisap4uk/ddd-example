# Evans DDD Terminology Glossary

Краткий словарь терминов из Eric Evans DDD, чтобы в команде одинаково понимать формулировки.

## Как трактовать термины

| Термин | Что это означает | Когда используем | Когда не используем | Пример в проекте |
|---|---|---|---|---|
| Ubiquitous Language | Единый язык домена для кода и обсуждений | Всегда: имена классов, методов, событий, полей | Не смешиваем термины разных контекстов | `Order`, `OrderItem`, `Promotion`, `Discount` |
| Entity | Объект с идентичностью и жизненным циклом | Когда важен именно экземпляр, а не только данные | Если объект равен только по значениям | `OrderItemEntity`, `OrderAggregate` |
| Value Object | Неизменяемое значение без собственной identity | Деньги, id-обёртки, параметры со строгими инвариантами | Когда нужен собственный lifecycle и identity | `MoneyValueObject`, `OrderIdValueObject`, `DiscountValueObject` |
| Aggregate | Кластер объектов с общей консистентностью | Когда инварианты нужно держать в одной транзакционной границе | Не делаем агрегат «на весь модуль» | `OrderAggregate` |
| Aggregate Root | Входная точка агрегата | Внешний код меняет состояние только через root | Нельзя менять внутренние сущности в обход root | `OrderAggregate` |
| Domain Service | Доменная операция, не принадлежащая одной Entity/VO | Когда правило домена «между объектами» | Не для orchestration/IO/технических задач | `DiscountPolicyPort` (+ реализации) |
| Repository | Абстракция хранения/восстановления агрегата | Для `save/getById` агрегата | Не содержит бизнес-правила | `OrderRepositoryInterface`, `InMemoryOrderRepository` |
| Factory | Создание агрегата/сущности с инвариантами | Когда конструирование нетривиально | Не для простого `new` без логики | `DefaultOrderFactory` |
| Specification | Явно выраженное бизнес-условие | Для проверок типа `canConfirm` | Не для технической валидации DTO | `DefaultOrderConfirmationSpecification` |
| Domain Event | Факт о том, что уже произошло в домене | Для публикации значимых доменных фактов | Не как команда «сделай X» | `OrderCreated`, `OrderConfirmed` |
| Application Service / Use Case | Оркестрация сценария и портов | Загрузить агрегат, вызвать доменную логику, сохранить | Не хранит доменные инварианты | `*.command.handler.ts`, `OrderQueryService` |
| Anti-Corruption Layer (ACL) | Перевод модели одного bounded context в другой | На границе контекстов | Не пропускаем внешний язык напрямую в domain | `PricingDiscountPolicyAcl` |
| Bounded Context | Граница модели и языка | Когда один и тот же термин имеет разный смысл | Не делаем «общую модель на всё» | `ordering` и `pricing` |
| Context Map | Карта отношений между bounded contexts | Для договорённостей интеграции | Не заменяет кодовые контракты | `docs/ddd/context-map.md` |

## Правила принятия решений

1. Есть identity и важна непрерывность экземпляра -> `Entity`.
2. Важны только значения и инварианты значения -> `Value Object`.
3. Правило домена не укладывается естественно в одну `Entity/VO` -> `Domain Service`.
4. Нужно защищать инварианты нескольких объектов вместе -> `Aggregate` и вход через `Aggregate Root`.
5. Нужна интеграция с другим контекстом -> только через `ACL`, без протекания внешних терминов в domain.

## Что это значит для нашего репозитория

1. Domain слой не зависит от `application` и `infrastructure`.
2. Persistence-снимки (`snapshot`) относятся к `infrastructure`, а не к domain.
3. Термины в событиях/контрактах должны быть единообразны (`quantity`, не `qty`).
4. Любые доменные проценты/деньги/идентификаторы держим в VO с явными инвариантами.

